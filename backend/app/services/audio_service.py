import os\nimport asyncio\nfrom typing import List, Dict, Any, Optional\nfrom pydub import AudioSegment\nfrom concurrent.futures import ThreadPoolExecutor\nimport json\nfrom datetime import datetime\n\nfrom ..core.config import settings\nfrom ..models.schemas import PlaylistItem, BookPlaylist\nfrom .epub_service import EpubService\nfrom .tts_service import TTSService\n\nclass AudioService:\n    def __init__(self):\n        self.epub_service = EpubService()\n        self.tts_service = TTSService()\n        self.executor = ThreadPoolExecutor(max_workers=settings.max_workers)\n    \n    async def merge_book_audio(self, book_id: str, chapter_ids: List[str]) -> str:\n        \"\"\"合并整本书的音频\"\"\"\n        try:\n            # 收集所有章节音频文件\n            audio_files = []\n            total_duration = 0.0\n            \n            for chapter_id in chapter_ids:\n                audio_info = await self.tts_service.get_chapter_audio_info(\n                    book_id, chapter_id\n                )\n                \n                if not audio_info:\n                    raise Exception(f\"章节 {chapter_id} 的音频文件不存在\")\n                \n                # 构建音频文件路径\n                audio_filename = f\"{book_id}_{chapter_id}.mp3\"\n                audio_path = os.path.join(settings.audio_dir, audio_filename)\n                \n                if os.path.exists(audio_path):\n                    audio_files.append(audio_path)\n                    total_duration += audio_info[\"duration\"]\n                else:\n                    raise Exception(f\"音频文件不存在: {audio_path}\")\n            \n            # 执行音频合并\n            merged_filename = f\"{book_id}_complete.mp3\"\n            merged_path = await self._merge_multiple_audio_files(\n                audio_files, merged_filename\n            )\n            \n            # 保存播放列表元数据\n            await self._save_book_metadata(\n                book_id, chapter_ids, total_duration, merged_filename\n            )\n            \n            return os.path.basename(merged_path)\n            \n        except Exception as e:\n            raise Exception(f\"合并音频失败: {str(e)}\")\n    \n    async def _merge_multiple_audio_files(self, audio_files: List[str], \n                                        output_filename: str) -> str:\n        \"\"\"合并多个音频文件\"\"\"\n        def _merge():\n            if not audio_files:\n                raise Exception(\"没有音频文件可合并\")\n            \n            # 加载第一个音频文件\n            merged_audio = AudioSegment.from_mp3(audio_files[0])\n            \n            # 依次合并其他音频文件\n            for audio_file in audio_files[1:]:\n                # 添加章节间隔（2秒静音）\n                silence = AudioSegment.silent(duration=2000)\n                next_audio = AudioSegment.from_mp3(audio_file)\n                merged_audio = merged_audio + silence + next_audio\n            \n            # 保存合并后的音频\n            output_path = os.path.join(settings.audio_dir, output_filename)\n            \n            # 导出为高质量MP3\n            merged_audio.export(\n                output_path,\n                format=\"mp3\",\n                bitrate=\"192k\",\n                tags={\n                    \"title\": \"Complete Audiobook\",\n                    \"artist\": \"Audio Book Translator\",\n                    \"genre\": \"Audiobook\"\n                }\n            )\n            \n            return output_path\n        \n        # 在线程池中执行\n        return await asyncio.get_event_loop().run_in_executor(\n            self.executor, _merge\n        )\n    \n    async def _save_book_metadata(self, book_id: str, chapter_ids: List[str], \n                                total_duration: float, merged_filename: str):\n        \"\"\"保存书籍音频元数据\"\"\"\n        metadata = {\n            \"book_id\": book_id,\n            \"chapter_ids\": chapter_ids,\n            \"total_duration\": total_duration,\n            \"merged_filename\": merged_filename,\n            \"created_at\": datetime.now().isoformat(),\n            \"chapter_count\": len(chapter_ids)\n        }\n        \n        # 保存元数据文件\n        metadata_path = os.path.join(settings.audio_dir, f\"{book_id}_metadata.json\")\n        with open(metadata_path, 'w', encoding='utf-8') as f:\n            json.dump(metadata, f, ensure_ascii=False, indent=2)\n    \n    def get_audio_file_path(self, audio_file: str) -> Optional[str]:\n        \"\"\"获取音频文件的完整路径\"\"\"\n        audio_path = os.path.join(settings.audio_dir, audio_file)\n        \n        if os.path.exists(audio_path) and os.path.isfile(audio_path):\n            return audio_path\n        \n        return None\n    \n    async def get_book_playlist(self, book_id: str) -> BookPlaylist:\n        \"\"\"获取书籍的播放列表\"\"\"\n        try:\n            # 获取书籍信息\n            chapters = self.epub_service.get_chapters(book_id)\n            \n            # 构建播放列表项\n            playlist_items = []\n            total_duration = 0.0\n            \n            for chapter in chapters:\n                # 检查章节音频是否存在\n                audio_info = await self.tts_service.get_chapter_audio_info(\n                    book_id, chapter.id\n                )\n                \n                if audio_info:\n                    item = PlaylistItem(\n                        chapter_id=chapter.id,\n                        chapter_title=chapter.title,\n                        audio_url=audio_info[\"audio_url\"],\n                        duration=audio_info[\"duration\"],\n                        order=chapter.order\n                    )\n                    playlist_items.append(item)\n                    total_duration += audio_info[\"duration\"]\n            \n            # 按章节顺序排序\n            playlist_items.sort(key=lambda x: x.order)\n            \n            # 获取书籍标题（假设从chapters中可以推断）\n            book_title = f\"Book {book_id}\"  # 这里可以从数据库或缓存获取实际标题\n            \n            return BookPlaylist(\n                book_id=book_id,\n                book_title=book_title,\n                total_duration=total_duration,\n                items=playlist_items\n            )\n            \n        except Exception as e:\n            raise Exception(f\"获取播放列表失败: {str(e)}\")\n    \n    async def create_chapter_segments(self, book_id: str, chapter_id: str, \n                                    segment_duration: int = 300) -> List[Dict[str, Any]]:\n        \"\"\"将章节音频分割成指定时长的片段（用于渐进式加载）\"\"\"\n        try:\n            # 获取章节音频文件\n            audio_filename = f\"{book_id}_{chapter_id}.mp3\"\n            audio_path = os.path.join(settings.audio_dir, audio_filename)\n            \n            if not os.path.exists(audio_path):\n                raise Exception(f\"章节音频文件不存在: {audio_filename}\")\n            \n            def _create_segments():\n                # 加载音频文件\n                audio = AudioSegment.from_mp3(audio_path)\n                audio_duration = len(audio)  # 毫秒\n                segment_duration_ms = segment_duration * 1000  # 转换为毫秒\n                \n                segments = []\n                segment_count = 0\n                \n                # 分割音频\n                for start_time in range(0, audio_duration, segment_duration_ms):\n                    end_time = min(start_time + segment_duration_ms, audio_duration)\n                    segment = audio[start_time:end_time]\n                    \n                    # 保存片段\n                    segment_filename = f\"{book_id}_{chapter_id}_seg_{segment_count:03d}.mp3\"\n                    segment_path = os.path.join(settings.audio_dir, segment_filename)\n                    \n                    segment.export(segment_path, format=\"mp3\", bitrate=\"128k\")\n                    \n                    segments.append({\n                        \"segment_id\": segment_count,\n                        \"filename\": segment_filename,\n                        \"start_time\": start_time / 1000.0,  # 转换为秒\n                        \"end_time\": end_time / 1000.0,\n                        \"duration\": (end_time - start_time) / 1000.0,\n                        \"url\": f\"/storage/audio/{segment_filename}\"\n                    })\n                    \n                    segment_count += 1\n                \n                return segments\n            \n            # 在线程池中执行\n            segments = await asyncio.get_event_loop().run_in_executor(\n                self.executor, _create_segments\n            )\n            \n            return segments\n            \n        except Exception as e:\n            raise Exception(f\"创建音频片段失败: {str(e)}\")\n    \n    async def cleanup_audio_files(self, book_id: str, chapter_ids: List[str] = None):\n        \"\"\"清理音频文件\"\"\"\n        try:\n            files_to_remove = []\n            \n            if chapter_ids:\n                # 清理指定章节的音频文件\n                for chapter_id in chapter_ids:\n                    audio_filename = f\"{book_id}_{chapter_id}.mp3\"\n                    audio_path = os.path.join(settings.audio_dir, audio_filename)\n                    if os.path.exists(audio_path):\n                        files_to_remove.append(audio_path)\n            else:\n                # 清理整本书的所有音频文件\n                audio_dir = settings.audio_dir\n                for filename in os.listdir(audio_dir):\n                    if filename.startswith(f\"{book_id}_\"):\n                        file_path = os.path.join(audio_dir, filename)\n                        if os.path.isfile(file_path):\n                            files_to_remove.append(file_path)\n            \n            # 删除文件\n            for file_path in files_to_remove:\n                try:\n                    os.remove(file_path)\n                except OSError:\n                    pass  # 忽略删除失败的文件\n            \n            return {\"deleted_files\": len(files_to_remove)}\n            \n        except Exception as e:\n            raise Exception(f\"清理音频文件失败: {str(e)}\")\n    \n    async def get_audio_statistics(self, book_id: str) -> Dict[str, Any]:\n        \"\"\"获取音频文件统计信息\"\"\"\n        try:\n            audio_dir = settings.audio_dir\n            stats = {\n                \"book_id\": book_id,\n                \"chapter_count\": 0,\n                \"total_size\": 0,\n                \"total_duration\": 0.0,\n                \"files\": []\n            }\n            \n            # 扫描音频文件\n            for filename in os.listdir(audio_dir):\n                if filename.startswith(f\"{book_id}_\") and filename.endswith(\".mp3\"):\n                    file_path = os.path.join(audio_dir, filename)\n                    file_size = os.path.getsize(file_path)\n                    \n                    # 获取音频时长\n                    try:\n                        audio = AudioSegment.from_mp3(file_path)\n                        duration = len(audio) / 1000.0  # 转换为秒\n                    except:\n                        duration = 0.0\n                    \n                    file_info = {\n                        \"filename\": filename,\n                        \"size\": file_size,\n                        \"duration\": duration,\n                        \"url\": f\"/storage/audio/{filename}\"\n                    }\n                    \n                    stats[\"files\"].append(file_info)\n                    stats[\"total_size\"] += file_size\n                    stats[\"total_duration\"] += duration\n                    \n                    if not filename.endswith(\"_complete.mp3\"):\n                        stats[\"chapter_count\"] += 1\n            \n            return stats\n            \n        except Exception as e:\n            raise Exception(f\"获取音频统计失败: {str(e)}\")